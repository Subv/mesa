/*
 * C11 <threads.h> emulation library
 *
 * (C) Copyright yohhoy 2012.
 * Distributed under the Boost Software License, Version 1.0.
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare [[derivative work]]s of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
#include <stdlib.h>
#ifndef assert
#include <assert.h>
#endif
#include <limits.h>
#include <errno.h>
#include <unistd.h>
#include <sched.h>
#include <stdint.h> /* for intptr_t */
#include <time.h>
#include <sys/time.h>

#include <switch.h>

/*---------------------------- macros ----------------------------*/
#define ONCE_FLAG_INIT {0}
#ifdef INIT_ONCE_STATIC_INIT
#define TSS_DTOR_ITERATIONS PTHREAD_DESTRUCTOR_ITERATIONS
#else
#define TSS_DTOR_ITERATIONS 1  // assume TSS dtor MAY be called at least once.
#endif

// FIXME: temporary non-standard hack to ease transition
#define _MTX_INITIALIZER_NP {0,0,{0,0,0}}

/*---------------------------- types ----------------------------*/
typedef u32     cnd_t;
typedef Thread* thrd_t;
typedef u32     tss_t;
typedef struct once_flag_t {
    long status;
} once_flag;
typedef struct mtx_t {
    int type;
    Mutex mutex;
    RMutex rmutex;
} mtx_t;

static u64 impl_timespec2nsec(const struct timespec *ts)
{
    return (u64)(ts->tv_sec * 1000000000 + ts->tv_nsec);
}

/*--------------- 7.25.2 Initialization functions ---------------*/
// 7.25.2.1
static inline void thrd_yield(void);
static inline void
call_once(once_flag *flag, void (*func)(void))
{
    assert(flag && func);
    if (__sync_val_compare_and_swap(&flag->status, 0, 1)) {
        (func)();
        __sync_val_compare_and_swap(&flag->status, 1, 2);
    } else {
        while (flag->status == 1) {
            // busy loop!
            thrd_yield();
        }
    }
}


/*------------- 7.25.3 Condition variable functions -------------*/
// 7.25.3.1
static inline int
cnd_broadcast(cnd_t *cond)
{
    assert(cond != NULL);
    return R_SUCCEEDED(svcSignalProcessWideKey((u32*)cond, -1)) ? thrd_success : thrd_error;
}

// 7.25.3.2
static inline void
cnd_destroy(cnd_t *cond)
{
    assert(cond);
}

// 7.25.3.3
static inline int
cnd_init(cnd_t *cond)
{
    assert(cond != NULL);
    *cond = 0;
    return thrd_success;
}

// 7.25.3.4
static inline int
cnd_signal(cnd_t *cond)
{
    assert(cond != NULL);
    return R_SUCCEEDED(svcSignalProcessWideKey((u32*)cond, 1)) ? thrd_success : thrd_error;
}

// 7.25.3.5
static inline int
cnd_timedwait(cnd_t *cond, mtx_t *mtx, const struct timespec *abs_time)
{
    Result rc;

    assert(mtx != NULL);
    assert(cond != NULL);
    assert(abs_time != NULL);
    assert(mtx->type == mtx_plain);

    // Construct the variable manually.
    CondVar var = { *cond, &mtx->mutex };
    rc = condvarWaitTimeout(&var, impl_timespec2nsec(abs_time));
    if (rc == 0xEA01) // timeout
        return thrd_busy;
    return R_SUCCEEDED(rc) ? thrd_success : thrd_error;
}

// 7.25.3.6
static inline int
cnd_wait(cnd_t *cond, mtx_t *mtx)
{
    assert(mtx != NULL);
    assert(cond != NULL);

    // Construct the variable manually.
    CondVar var = { *cond, &mtx->mutex };
    return R_SUCCEEDED(condvarWait(&var)) ? thrd_success : thrd_error;
}


/*-------------------- 7.25.4 Mutex functions --------------------*/
// 7.25.4.1
static inline void
mtx_destroy(mtx_t *mtx)
{
    assert(mtx != NULL);
}

// 7.25.4.2
static inline int
mtx_init(mtx_t *mtx, int type)
{
    assert(mtx != NULL);
    assert(type == mtx_plain || type == mtx_recursive);
    mtx->type = type;
    mutexInit(&mtx->mutex);
    rmutexInit(&mtx->rmutex);
    return thrd_success;
}

// 7.25.4.3
static inline int
mtx_lock(mtx_t *mtx)
{
    assert(mtx != NULL);
    if (mtx->type & mtx_recursive)
        rmutexLock(&mtx->rmutex);
    else
        mutexLock(&mtx->mutex);
    return thrd_success;
}

// 7.25.4.4
static inline int
mtx_timedlock(mtx_t *mtx, const struct timespec *ts)
{
    return thrd_error;
}

// 7.25.4.5
static inline int
mtx_trylock(mtx_t *mtx)
{
    return thrd_error;
}

// 7.25.4.6
static inline int
mtx_unlock(mtx_t *mtx)
{
    assert(mtx != NULL);
    if (mtx->type & mtx_recursive)
        rmutexUnlock(&mtx->rmutex);
    else
        mutexUnlock(&mtx->mutex);
    return thrd_success;
}


/*------------------- 7.25.5 Thread functions -------------------*/
// 7.25.5.1
static inline int
thrd_create(thrd_t *thr, thrd_start_t func, void *arg)
{
    assert(thr);
    *thr = (thrd_t)malloc(sizeof(Thread));
    Result rc = threadCreate(*thr, (ThreadFunc)func, arg, 1024 * 1024, 0x2C, -2);
    return R_SUCCEEDED(rc) ? thrd_success : thrd_error;
}

// 7.25.5.2
//static inline thrd_t
//thrd_current(void);

// 7.25.5.3
//static inline int
//thrd_detach(thrd_t thr);

// 7.25.5.4
static inline int
thrd_equal(thrd_t thr0, thrd_t thr1)
{
    return thr0->handle == thr1->handle;
}

// 7.25.5.5
static inline void
thrd_exit(int res)
{
    svcExitThread();
}

// 7.25.5.6
static inline int
thrd_join(thrd_t thr, int *res)
{
    if (R_FAILED(threadWaitForExit(thr)))
        return thrd_error;

    if (R_FAILED(threadClose(thr)))
        return thrd_error;

    free(thr);

    if (res)
        *res = 0;
    return thrd_success;
}

// 7.25.5.7
static inline void
thrd_sleep(const struct timespec *time_point, struct timespec *remaining)
{
    assert(time_point != NULL);
    assert(!remaining);
    svcSleepThread(impl_timespec2nsec(time_point));
}

// 7.25.5.8
static inline void
thrd_yield(void)
{
    svcSleepThread(10);
}


/*----------- 7.25.6 Thread-specific storage functions -----------*/
// 7.25.6.1
static inline int
tss_create(tss_t *key, tss_dtor_t dtor)
{ return thrd_error; }

// 7.25.6.2
static inline void
tss_delete(tss_t key)
{ }

// 7.25.6.3
static inline void *
tss_get(tss_t key)
{ return NULL; }

// 7.25.6.4
static inline int
tss_set(tss_t key, void *val)
{ return thrd_error; }


/*-------------------- 7.25.7 Time functions --------------------*/
// 7.25.6.1
#ifndef HAVE_TIMESPEC_GET
static inline int
timespec_get(struct timespec *ts, int base)
{
    if (!ts) return 0;
    if (base == TIME_UTC) {
        struct timeval tv;
        gettimeofday(&tv, NULL);
        ts->tv_sec = tv.tv_sec;
        ts->tv_nsec = tv.tv_usec * 1000;
        return base;
    }
    return 0;
}
#endif
